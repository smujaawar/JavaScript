// Arrow functions are one of the most important **ES6+ features** in JavaScript. They provide a **shorter syntax** for writing functions and have **unique behavior for `this` binding**. Let’s go **in-depth** with everything you need to know:

// ---

// ##  **1. What is an Arrow Function?**

// An **arrow function** is a new syntax introduced in ES6 for defining functions in a concise way. Unlike traditional functions, arrow functions **do not have their own `this`, `arguments`, `super`, or `new.target`**.

// ---

// ###  **Syntax**

// ```js
// // Traditional function
// function add(a, b) {
//   return a + b;
// }

// // Arrow function
// const add = (a, b) => a + b;
// ```

// ---

// ##  **2. Why Use Arrow Functions?**

// * Shorter and cleaner syntax.
// * Lexical `this` (does not create its own `this`).
// * Cannot be used as constructors (prevents accidental `new` calls).
// * Great for **callbacks** and **functional programming**.

// ---

// ##  **3. Characteristics of Arrow Functions**

// | Feature                     | Arrow Function                       |
// | --------------------------- | ------------------------------------ |
// | `this` binding              | Lexical (inherits from parent scope) |
// | `arguments` object          | Not available (use rest params)      |
// | `new` keyword (constructor) | Cannot be used                     |
// | `prototype` property        | Does not exist                     |
// | Implicit return             |  For single-expression body         |

// ---

// ---

// ##  **4. Syntax Variations**

// ### **Basic:**

// ```js
// const greet = () => console.log("Hello!");
// ```

// ### **With one parameter:**

// ```js
// const square = x => x * x;
// ```

// ### **With multiple parameters:**

// ```js
// const sum = (a, b) => a + b;
// ```

// ### **With multiple statements:**

// ```js
// const calc = (a, b) => {
//   const result = a + b;
//   return result;
// };
// ```

// ### **Returning an object:**

// ```js
// const getUser = () => ({ name: "Alice", age: 25 });
// ```

// *(Wrap object in `()` to avoid `{}` being treated as a block.)*

// ---

// ---

// ##  **5. Behavior of `this`**

// This is **the most important concept** about arrow functions.

// * **Normal Function:** `this` depends on how the function is called.
// * **Arrow Function:** `this` is **lexically scoped** (inherits from the surrounding context).

// ### Example:

// ```js
// const obj = {
//   value: 10,
//   normal: function () {
//     console.log(this.value); // 10
//   },
//   arrow: () => {
//     console.log(this.value); // undefined (because it takes `this` from global scope)
//   }
// };

// obj.normal();
// obj.arrow();
// ```

// ---

// ###  **In Callbacks**

// ```js
// function Timer() {
//   this.seconds = 0;
//   setInterval(() => {
//     this.seconds++;
//     console.log(this.seconds);
//   }, 1000);
// }
// new Timer();
// ```

// *(Works because arrow function doesn’t create its own `this`.)*

// ---

// ---

// ##  **6. Arrow Functions vs Normal Functions**

// | Feature                  | Normal Function | Arrow Function |
// | ------------------------ | --------------- | -------------- |
// | Has `this`               | Yes (dynamic)   | No (lexical)   |
// | Can be constructor       |  Yes           |  No           |
// | Has `arguments`          |  Yes           |  No           |
// | Has `prototype` property |  Yes           |  No           |
// | Short syntax             |  No            |  Yes          |

// ---

// ---

// ##  **7. Where to Use Arrow Functions**

// ✔ Callback functions (e.g., in `map`, `filter`, `reduce`)
// ✔ Event listeners **when you don’t need `this`**
// ✔ Short utility functions
// ✔ Promise chains and async callbacks

// ---

// ---

// ##  **8. Where NOT to Use Arrow Functions**

//  As **methods in objects** when you need `this`
//  As **constructors**
//  For **functions needing `arguments` object**
//  Inside **prototype methods of classes**

// ---

// ---

// ##  **9. Common Interview Questions**

// ### **Q1:** What will this print?

// ```js
// const obj = {
//   count: 10,
//   regular: function () {
//     setTimeout(function () {
//       console.log(this.count);
//     }, 1000);
//   },
//   arrow: function () {
//     setTimeout(() => {
//       console.log(this.count);
//     }, 1000);
//   }
// };

// obj.regular(); // ?
// obj.arrow();   // ?
// ```

// **Answer:**

// * `obj.regular()` → `undefined` (because inside `setTimeout` normal function `this` is global)
// * `obj.arrow()` → `10` (arrow function inherits `this` from `arrow()` method context)

// ---

// ---

// ##  **10. Real-World Examples**

// ### **Array methods**

// ```js
// const numbers = [1, 2, 3];
// const squares = numbers.map(n => n * n);
// console.log(squares); // [1, 4, 9]
// ```

// ### **Promise chain**

// ```js
// fetch('https://api.example.com')
//   .then(response => response.json())
//   .then(data => console.log(data));
// ```

// ---

// ---

// ##  **11. Tricky Points**

// * Arrow functions **cannot use `arguments`** → use rest operator:

// ```js
// const sum = (...nums) => nums.reduce((a, b) => a + b, 0);
// ```

// * They **cannot be hoisted** like normal function declarations.
// * They **always return `undefined`** if no `return` is used for multi-line.

// ---

// ---
